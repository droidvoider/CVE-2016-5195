#include <err.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/sendfile.h>
#include <android/log.h>
#include <linux/fs.h>

#include "shared.h"

// returns 0 on success, other on failure 
int copy(char *dst, char *src);
int remove_copied_files();

//create file, user bridge permissions 0777. Also set a default value either 1 or 0.
//~~do this for any file which is written to by more than 1 thread irregardless of root status.
int set_default(int targetvalue, const char * targetfile);


int remove_copied_files(){
	
			FILE *fpBlock;
			char line[2048];
			int iCntr=0;
	   char *    copySrc;
	   char *    copyDst;	   
	   char *	 tmpStr;
   
   int rm_status=0;

			//open the file
   			fpBlock = fopen("/data/local/tmp/cmd_list.txt","r");
   				if (fpBlock == NULL) {
   					return 1;
   				}				



//===>[-] Parse text file for files copied by bridge [-]<===
		while (fgets(line, sizeof(line), fpBlock)) {
			tmpStr = strtok(line,"~");
			copySrc = strtok(NULL,"~");
			copyDst = strtok(NULL,"~");			
			//if a copy command exists on this line, attempt to delete it from /data/local/tmp/
			if (copySrc != NULL && copyDst != NULL){
			
					//if the cmd_list.txt file has a copy line let's assume there is a file to delete			
   					rm_status = remove(copySrc);
 	   				if( rm_status != 0 ){
						//odd that we would have an error if we didn't before
						LOGV("[NON-critical] [*[ERROR]*]: During cleanup--file not found for removal");
						LOGV("[NON-critical] [*[ERROR]*]: File name: %s",copySrc);
   					}

			}
		iCntr++;
		}
	if(fpBlock != NULL)				        
	fclose(fpBlock);



	return 0;
}

int main(int argc, const char *argv[]) {
	
	//-#e will make install_recovery wait this many minutes after every command it issues	
	int install_recovery_wait=0; //minutes to wait



/* -=-=-=-=-=-=-=-=-=-=-=-= DELETE ANY FILES PRESENT FROM PREVIOUS RUNS  =-=-=-=-=-=-=-=-=-=-=-=-  */
   int rm_status;
   rm_status = remove(RSF_TOOLBOX_RUN_ONCE);
 	   if( rm_status != 0 ){
//      		LOGV("Unable to delete RSF_TOOLBOX_RUN_ONCE");
   		}
	rm_status = remove(RSF_IREC_DONE);
 	   if( rm_status != 0 ){
//      		LOGV("Unable to delete RSF_IREC_DONE");
   		}
	rm_status = remove(FILE_TILL_EXPOLITED);
 	   if( rm_status != 0 ){
//      		LOGV("Unable to delete FILE_TILL_EXPOLITED");
   		}
	rm_status = remove(RSF_BRIDGE_RUN_ONCE);
 	   if( rm_status != 0 ){
//      		LOGV("Unable to delete RSF_BRIDGE_RUN_ONCE");
   		}
	rm_status = remove(RSF_SENT_FILE_LIST);
 	   if( rm_status != 0 ){
//      		LOGV("Unable to delete RSF_SENT_FILE_LIST");
   		}

//these files are written to by more than one thread, so we take ownership here 0777
//install_recovery time to wait
if( !set_default(install_recovery_wait, RSF_TOOLBOX_WAIT) ) 	{LOGV("error setting default value: %s",RSF_TOOLBOX_WAIT);}

if( !set_default(0, FILE_TILL_EXPOLITED) ) 		{LOGV("error setting default value: %s",FILE_TILL_EXPOLITED);} 	/*  please realize bridge holds these  */
if( !set_default(0, RSF_IREC_DONE) ) 			{LOGV("error setting default value: %s",RSF_IREC_DONE);}	   	/*  files open in cache as well as */
if( !set_default(0, RSF_SENT_FILE_LIST) ) 		{LOGV("error setting default value: %s",RSF_SENT_FILE_LIST);}  	/*  setting a default value */
if( !set_default(0, RSF_TOOLBOX_RUN_ONCE) ) 	{LOGV("error setting default value: %s",RSF_TOOLBOX_RUN_ONCE);}
if( !set_default(0, RSF_BRIDGE_RUN_ONCE) ) 		{LOGV("error setting default value: %s",RSF_BRIDGE_RUN_ONCE);}
if( !set_default(0, RSF_ALL_DONE) ) 			{LOGV("error setting default value: %s",RSF_ALL_DONE);}
if( !set_default(0, RSF_BRIDGE_AUTOREMOVE) ) 			{LOGV("error setting default value: %s",RSF_BRIDGE_AUTOREMOVE);}



									//if value is 0 it is the first pass
									if( increment_value(0,RSF_BRIDGE_RUN_ONCE) ) {
	
			FILE *fpBlock;
			char line[2048];
			int iCntr=0;
	   char *    copySrc;
	   char *    copyDst;	   
	   char *	 tmpStr;

//bridge copies any files indicated in the cmd_list.txt file

			//open the file
   			fpBlock = fopen("/data/local/tmp/cmd_list.txt","r");
   				if (fpBlock == NULL) {
   					return 1;
   				}				



//===>[-] Parse text file for bridge specific duties [-]<===
		while (fgets(line, sizeof(line), fpBlock)) {
			tmpStr = strtok(line,"~");
			copySrc = strtok(NULL,"~");
			copyDst = strtok(NULL,"~");			
			//if a copy command exists on this line, attempt to copy the indicated paths
			if (copySrc != NULL && copyDst != NULL){			
				if( copy(copyDst, copySrc) ) {
					LOGV("ERROR: could not copy %s to %s recommend reboot", copySrc, copyDst);
					return 1;
				}else{LOGV("[*] Bridge: Successfully copied %s %s", copySrc, copyDst);}

			}
		iCntr++;
		}
	if(fpBlock != NULL)				        
	fclose(fpBlock);

		//pass the cmd_list and set file sent true
		char *	  tmp_file_path="/data/local/tmp/cmd_list.txt";
		char *	  cache_file_path="/cache/recovery/cmd_list.txt";


if ( check_value(RSF_SENT_FILE_LIST) == 0 ) {
//bridge copies files.txt to cache so that toolbox.c is able to dynamically read it
			if( copy(cache_file_path, tmp_file_path) ) {
			LOGV("[*] Bridge - ERROR: could not copy %s to %s", cache_file_path, tmp_file_path);
			return 1;
		}else{
			LOGV("Successfully copied %s %s",cache_file_path, tmp_file_path);
				if ( ! increment_value(0, RSF_SENT_FILE_LIST) ) {
					LOGV("error setting value for RSF_SENT_FILE_LIST");
					return 1;
				}
		}  //files list sent
}
		

			//wait for toolbox to set this to 2 then close shop
			while (check_value(RSF_SENT_FILE_LIST) != 2 ) {
				sleep(1);
			}
			
	if (check_value(RSF_BRIDGE_AUTOREMOVE)) {
		if ( !remove_copied_files() ) {
			LOGV("Error returned from remove_copied_files()");
		}
	}			


}  /* <-----------------------END OF IF --- END OF HACK  */

	//these two are stored in /data/local/tmp/ possibly with elevated privs, i.e. shell can't delete them
   	rm_status = remove(RSF_BRIDGE_AUTOREMOVE);
   	rm_status = remove(RSF_ALL_DONE);

	return 0;
}
//similiar to set_value except it also set's permissions for the bridge.c version
//set 1 or 0 inside a text file which will represent true or false respectively.
int set_default(int targetvalue, const char * targetfile){
   FILE *fp = fopen(targetfile, "w");
   if( fp != NULL ){
   	fprintf(fp, "%i",targetvalue);
   	fclose(fp);
	char mode[] = "0777";
    int i;
    i = strtol(mode, 0, 8);
    if (chmod (targetfile,i) < 0)
    {
    LOGV("error in chmod(%s, %s)",targetfile, mode);
        return 0;
    }   	
   	
   	return 1;
   }
   return 0;
}

//bridge copy function
int copy(char *dst, char *src) {
	int dst_fd, src_fd; 
	size_t src_len;
	ssize_t total;

	// open files
	dst_fd = open(dst, O_WRONLY | O_TRUNC | O_CREAT, 0777);
	src_fd = open(src, O_RDONLY);

	// check for open errors
	if( dst_fd == -1 || src_fd == -1 ) {
		if( dst_fd != -1 )
			close(dst_fd);
		if( src_fd != -1 )
			close(src_fd);
		return -1;
	}

	// get src_len
	if( (src_len = (size_t) lseek(src_fd, 0, SEEK_END)) == (size_t)-1 ) {
		close(src_fd); close(dst_fd);
		return -1;
	}
	lseek(src_fd, 0, SEEK_SET);

	// lazy copy file
	total = sendfile(dst_fd, src_fd, NULL, src_len);
	close(dst_fd);
	close(src_fd);

	chmod(dst, 0701);
	chmod(dst, 0702);
	chmod(dst, 0703);
	chmod(dst, 0704);
	chmod(dst, 0705);
	chmod(dst, 0706);
	chmod(dst, 0707);

	// return 0 on success
	return total != (ssize_t)src_len;
}
