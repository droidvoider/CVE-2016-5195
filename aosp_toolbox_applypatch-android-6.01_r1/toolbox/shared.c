#include "shared.h"
#include <stdio.h>

const char * RSF_SENT_FILE_LIST			/* toolbox.c shouldn't read until bridge is finished writing */
										//~~~
										/* bridge.c dual purpose -- when RSF_SENT_FILE_LIST == 0 again toolbox is all done */
= "/cache/recovery/.sent_file_list";

			/* commands will execute consecutively in cmd_list.txt */
const char * RSF_IREC_DONE	 	 /* bridge.c sets this to 1 to let farm.c know that exploit is complete, ok to close */
								 /* system _server / install_recovery both loop to test each line of cmd_list.txt 
									   0 = install_recovery tests and if applies issues command
									   1 = system_server test and then and if applies issues command */
="/cache/recovery/.irec_done";									   


		/* toolbox.c only run the exploit once. without this it would keep spawning exploit procs */
		const char * RSF_TOOLBOX_RUN_ONCE
= "/cache/recovery/.toolbox";		


//set an integer value to represent an option.
int set_value(int targetvalue, const char * targetfile){
   FILE *fp = fopen(targetfile, "w"); /* <DEBUG> "w" is overwrite but same permissons when file exists?, we will see */
   if( fp != NULL ){
   		fprintf(fp, "%i",targetvalue);
   		fclose(fp);
   		return 1;
   }
	return 0;
}

//returns an integer from a text file
int check_value(const char * targetfile){
   int return_value;
   
   FILE *fp = fopen(targetfile, "r");
   if (fp == NULL) 
   {
   	LOGV("check_value tested a null targetfile %s",targetfile);
   	return 0;
   }
	fscanf(fp, "%i", &return_value);
    	     fclose(fp);
    	return return_value;
}

//int is for expected value, const char * is for above const char * file path
int increment_value(int required_value, const char * targetfile){  /* if expected_value == current file value it will increment that value by 1
											   						  otherwise it will evulate false i.e. return 0 */
   	int return_value;
   
   	//retrieve the currently stored option value
   	FILE *fp = fopen(targetfile, "r");
   	if (fp == NULL) 
   	{
   		LOGV("check_value tested a null targetfile %s",targetfile);
   		return 0;
	}
	fscanf(fp, "%i", &return_value);
   	fclose(fp);

   //if the value was the required_value, i.e. if it was 0 for example
   if ( return_value == required_value ){
   		FILE *fp = fopen(targetfile, "w"); /* i don't test for null a second time <DEBUG>, should be ok */
			return_value++; /* increment and reuse this variable */
   			fprintf(fp, "%i",return_value);
   			fclose(fp);
	   		return 1;
   		}else{return 0;}   
	LOGV("change attempt fail %s expected value: %i but was %i",targetfile, required_value, return_value);
	return 0;
}
