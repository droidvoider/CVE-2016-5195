#include <sys/stat.h>
#include <stdio.h>

#include "shared.h"

//these are files used with readystate logic, cross process communications

const char * RSF_IREC_DONE												="/cache/recovery/.irec_done";
								  		/* system _server / install_recovery both loop to test each line of cmd_list.txt 
											0 = install_recovery tests and if applies issues command
											1 = system_server test and then and if applies issues command */
		/* toolbox.c only run SERVER_CONTEXT once */
const char * RSF_TOOLBOX_RUN_ONCE 										= "/cache/recovery/.toolbox";

		/* toolbox will wait if -#e is in the cmd_list.txt file for the minutes set in bridge.c default value, this file */
const char * RSF_TOOLBOX_WAIT											="/cache/recovery/.toolbox_wait";
											

const char * FILE_TILL_EXPOLITED										="/cache/recovery/.till_expolit_active";
								  /* if 1 then till has already ran, ignore successive install_recovery passes */
								  /* this file is actually set by toolbox.c when control returns with install_recovery context */					


const char * RSF_BRIDGE_RUN_ONCE  										="/cache/recovery/.bridge_run_once";
								  /* if exists bridge.c has already ran the exploit */
								  		
const char * RSF_BRIDGE_AUTOREMOVE 										="/data/local/tmp/.bridge_autoremove";
								  /* autoremove for bridge -- removes files copied to /data/local/tmp/ by Makefile */



										/* toolbox.c shouldn't read until bridge is finished writing */
										//~~~
										/* bridge.c dual purpose -- when RSF_SENT_FILE_LIST == 0 again toolbox is all done */
const char * RSF_SENT_FILE_LIST											= "/cache/recovery/.sent_file_list";								  		


										/* bridge.c sets this to 1 to let farm.c know that exploit is complete, ok to close */
const char * RSF_ALL_DONE												= "/data/local/tmp/.farming_completed";


//function definitions for cross process communication logic

//int is for expected value, const char * is for above const char * file path
int increment_value(int required_value, const char * targetfile){  /* if expected_value == current file value it will increment that value by 1
											   						  otherwise it will evulate false i.e. return 0 */
   	int return_value;
   
   	//retrieve the currently stored option value
   	FILE *fp = fopen(targetfile, "r");
   	if (fp == NULL) 
   	{
   		LOGV("check_value tested a null targetfile %s",targetfile);
   		return 0;
	}
	fscanf(fp, "%i", &return_value);
   	fclose(fp);

   //if the value was the required_value, i.e. if it was 0 for example
   if ( return_value == required_value ){
   		FILE *fp = fopen(targetfile, "w"); /* i don't test for null a second time <DEBUG>, should be ok */
			return_value++; /* increment and reuse this variable */
   			fprintf(fp, "%i",return_value);
   			fclose(fp);
	   		return 1;
   		}else{return 0;}   
	LOGV("change attempt fail %s expected value: %i but was %i",targetfile, required_value, return_value);
	return 0;
}


//set an integer value to represent an option.
int set_value(int targetvalue, const char * targetfile){
   FILE *fp = fopen(targetfile, "w"); /* <DEBUG> "w" is overwrite but same permissons when file exists?, we will see */
   if( fp != NULL ){
   		fprintf(fp, "%i",targetvalue);
   		fclose(fp);
   		return 1;
   }
	return 0;
}

//returns an integer from a text file
int check_value(const char * targetfile){
   int return_value;
   
   FILE *fp = fopen(targetfile, "r");
   if (fp == NULL) 
   {
   	printf("check_value tested a null targetfile %s\n",targetfile);
   	return -1;
   }
	fscanf(fp, "%i", &return_value);
    	     fclose(fp);
    	return return_value;
}
