#include <sys/stat.h>
#include <stdio.h>

#include "shared.h"

//these are files used with readystate logic, cross process communications

										const char * RSF_IREC_DONE		="/cache/recovery/.irec_done";
								  		/* system _server / install_recovery both loop to test each line of cmd_list.txt 
											0 = install_recovery tests and if applies issues command
											1 = system_server test and then and if applies issues command */
		/* toolbox.c only run SERVER_CONTEXT once */
		const char * RSF_TOOLBOX_RUN_ONCE = "/cache/recovery/.toolbox";											

const char * FILE_TILL_EXPOLITED="/cache/recovery/.till_expolit_active";
								  /* if file exists till has already ran, ignore successive install_recovery passes */						


const char * RSF_BRIDGE_RUN_ONCE  										="/cache/recovery/.bridge_run_once";
								  /* if exists bridge.c has already ran the exploit */
								  		


										/* toolbox.c shouldn't read until bridge is finished writing */
										//~~~
										/* bridge.c dual purpose -- when RSF_SENT_FILE_LIST == 0 again toolbox is all done */
const char * RSF_SENT_FILE_LIST											= "/cache/recovery/.sent_file_list";								  		


										/* bridge.c sets this to 1 to let farm.c know that exploit is complete, ok to close */
const char * RSF_ALL_DONE												= "/data/local/tmp/.farming_completed";


//function definitions for cross process communication logic

int increment_value(int required_value, const char * targetfile){
//FILE_TILL_EXPOLITED
   int return_value;
   
   //retrieve the currently stored option value
   FILE *fp = fopen(targetfile, "r");
   if (fp == NULL) 
   {
   	printf("check_value tested a null targetfile %s\n",targetfile);
   	return -1;
   }
	fscanf(fp, "%i", &return_value);
   		fclose(fp);

   //if the value was the required_value, i.e. if it was 0 for example
   if ( return_value == required_value ){
   		FILE *fp = fopen(targetfile, "w"); /* <DEBUG> "w" is overwrite but same permissons when file exists?, we will see */
   		if( fp != NULL ){
			return_value++; /* increment and reuse this variable */
   			fprintf(fp, "%i",return_value);
   			fclose(fp);
	   		return 1;
   		}else{return -1;}   
   }
	LOGV("change attempt fail %s expected value: %i but was %i",targetfile, required_value, return_value);
	return 0;
}


//set an integer value to represent an option.
int set_value(int targetvalue, const char * targetfile){
   FILE *fp = fopen(targetfile, "w"); /* <DEBUG> "w" is overwrite but same permissons when file exists?, we will see */
   if( fp != NULL ){
   		fprintf(fp, "%i",targetvalue);
   		fclose(fp);
   		return 1;
   }
	return 0;
}

//returns an integer from a text file
int check_value(const char * targetfile){
   int return_value;
   
   FILE *fp = fopen(targetfile, "r");
   if (fp == NULL) 
   {
   	printf("check_value tested a null targetfile %s\n",targetfile);
   	return -1;
   }
	fscanf(fp, "%i", &return_value);
    	     fclose(fp);
    	return return_value;
}

//delete a file if success return 1 otherwise failed to delete file return 0
int delete_file(const char * src){
 	   if( remove(src) != 0 ) {
      		LOGV("error: delete_file(): %s",src);
      		perror("Error");
      		return 0;
   		}
	return 1;   		
}

//check if file exists then return 1 otherwise file doesn't exist return 0
int file_validity(const char * src){
   FILE *fptest_null = fopen(src, "r");
   if (fptest_null != NULL) {
   	fclose(fptest_null);
   	return 1;
   }
   	return 0;
}
