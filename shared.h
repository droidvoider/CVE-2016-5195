#ifndef __SHARED_H__
#define __SHARED_H__

#include <android/log.h>


								  		/* File used to store process id, first of system_server then that pid becomes install_recovery */
								  		/* forked() system_server pid is not saved it is only needed for till 'applypatch' logic */
		/* toolbox.c only run SERVER_CONTEXT once */
		const char * RSF_TOOLBOX_RUN_ONCE;								  		

const char * RSF_IREC_DONE; 	 
								  		/* system _server / install_recovery both loop to test each line of cmd_list.txt 
											0 = install_recovery tests and if applies issues command
											1 = system_server test and then and if applies issues command */
									
const char * FILE_TILL_EXPOLITED;
								  /* if file exists till has already ran, ignore successive install_recovery passes */
								  
const char * RSF_BRIDGE_RUN_ONCE;
								  /* if exists bridge.c has already ran the exploit */

const char * RSF_SENT_FILE_LIST;
										/* toolbox.c shouldn't read until bridge is finished writing */
										//~~~
										/* bridge.c dual purpose -- when RSF_SENT_FILE_LIST == 0 again toolbox is all done */

										/* bridge.c sets this to 1 to let farm.c know that exploit is complete, ok to close */
const char * RSF_ALL_DONE;										


			/* Function Declarations */
int increment_value(int, const char *);

//check if file exists then return 1 otherwise file doesn't exist return 0
int file_validity(const char *);

//test our the state of our true/false 'ready state' logic files.
int check_value(const char *);

//set 1 or 0 inside a text file which will represent true or false respectively.
int set_value(int, const char *);

// log info
#define LOGV(...) { __android_log_print(ANDROID_LOG_INFO, "droid_dd_dcow", __VA_ARGS__); }

// log notice
#define LOGN(x) { __android_log_print(ANDROID_LOG_INFO, "droid_dd_dcow", "NOTICE: %s", (x)); }
#endif
